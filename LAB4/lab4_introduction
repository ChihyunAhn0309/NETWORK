CS30401 Network Lab 4: Implement (Mini) Onion Routing Protocol
Logistics
The due date is 23:59 (KST) on December 7, 2025.
Submit your files in a zip format to Gradescope with its name as {SID}.zip.
Discussion and Q&A: “Labs” tag at Classum
Overview
In this lab, you will implement a simplified version of the onion routing (or Tor) protocol. The onion routing protocol is often used for anonymous communication over networks. Instead of directly connecting to the web server, the client uses relays (or onion routers) to encapsulate the message. Each relay decrypts a single layer of encryption and forwards the message to the next relay until the message reaches the final destination server. This ensures that no single relay knows both the origin and destination of the message.

The goal of this lab is to construct an onion circuit that allows a client to deliver a message to a web server while preserving the anonymity of the client. In this lab, you will learn how onion routing enables secure and anonymous message delivery over a network.

The lab has four main tasks: (1) opening channel and circuit to the first relay, (2) extending the circuit, (3) connecting to a web server via the circuit, and (4) closing the circuit. You can find more details in each task description.

Please note that our mini onion routing protocol is a simplified version of the actual Tor protocol. While it mimics the core onion encryption logic, it is not fully compatible with Tor. Therefore, you should NOT use this mini protocol to hide your identity on the Internet.
Preliminaries
Relay
Relays, also known as onion routers, are the nodes that form a circuit. A circuit is a series of relays, where each relay passes data to the next. The client is always at the beginning of the circuit, and the final relay connects to the web server requested by the client. In this lab, we will use a 3-hop circuit consisting of three relays.
Authority
In the mini onion routing protocol, the authority is a centralized, fully trusted server that maintains information about each relay’s IP address and identity. The authority’s IP address, port, and public key are publicly known. (Similarly, in Tor, a default list of authorities is included with the software.)

The authority provides server descriptors that contain each relay’s nickname, IP address, port, public key, and signature. By fetching these descriptors, a client can choose which relays to include in a circuit, and relays can also learn about their peers.
Asymmetric Encryption Scheme: RSA 2048
All relays and the authority have their own RSA public-private key pairs, also known as identity keys. The identity keys are used to prove/verify the entities, and to securely communicate with the entities. To serve this purpose, the private key should never leave the entity, while the public key is advertised and shared with others.

RSA key pairs are used to encrypt messages or generate digital signatures. An entity A can encrypt a message using entity B’s public key. This encrypted message can only be decrypted by entity B who owns the associated private key. By encrypting the message, entity A can securely share the message only with entity B.

An entity A can also generate a signature by signing a message using its private key. By knowing the public key of entity A, the signature, and the original message, any entity can confirm that the signature is generated by entity A and know that the message is not modified.
Diffie-Hellman Key Exchange
Diffie-Hellman (DH) key exchange scheme is used to derive a shared secret key. There will be two entities trying to derive an identical shared secret key. In all practical DH key exchange schemes, all participating entities already agree on the public parameters p and g, which are publicly known to every entity in advance. Then, each of them generates a public-private DH key pair (note that this is different from RSA key pairs) and exchanges the public keys. After exchanging the public keys, each can derive a shared secret key by combining a peer's public key and its own private key locally.

The public parameters p and g used in the mini onion routing protocol are already listed in the codes. We will use 2 for g, and  0xBC6E230F63512CB36605599417DE96B6DE189B93 E63250EFAF457462533D8EBBEF362F478BDBDAEB4E0726F4102F54F6B58CB70C5257A829456D981A2E5FCD7B for p.

In the mini onion routing protocol, a client and each relay in the circuit derive a shared secret key. For example, a client derives shared secret key K1 with relay 1, and shared secret key K2 with relay 2, and so on. Throughout this document, when we refer to a DH public key, we mean the actual numbers (see the examples in mini_crypt.py).
Symmetric Encryption Scheme: AES
After a client and the three relays in a circuit derive shared keys, these keys are used to encrypt the RELAY cell (explained later in this document). As each relay forwards the cell along the circuit, it decrypts one layer and passes it to the next relay. This process gives the protocol its name: onion routing — each layer of encryption (or onion layer) is peeled away by a relay. In an N-hop circuit, the client wraps the RELAY cell with N layers of encryption, and only the final relay can read the cell’s contents after all layers have been removed.
Channel and Cell
A channel is a direct, encrypted connection between two relays or between a client and a relay. The basic unit of communication on a channel is called a cell. Once a socket connection is established, the two parties exchange specific cells to open a channel. After the channel is open, they can exchange regular cells. Note that cells are sent serially, one at a time, and come in two types: fixed-length cells and variable-length cells.

A fixed-length cell has the following format:
Field
Size in bytes
Notes
CircID
2


Command
1


Body
1024
Padded to fit the fixed size; format varies depending on the cell command


A variable-length cell has the following format:
Field
Size in bytes
Notes
CircID
2


Command
1


Length
2
A big-endian integer
Body
Length
Format varies depending on the cell command



Interpreting the fields: CircID. The CircID field determines which circuit the cell is associated with. If the cell is not associated with any circuit, its CircID is set to 0. Note that a CircID is a channel-local identifier. A single multi-hop circuit will have a different CircID on every channel that is used to transmit its data.


Interpreting the fields: Command. The command field holds one of the following values:
Value
C
L
Identifier
Description
1
Y
Y
CREATE
Create a circuit
2
Y
Y
CREATED
Acknowledge CREATE
3
Y
N
RELAY
End-to-end data, fixed-length cell
4
Y
N
DESTROY
Destroy a circuit, fixed-length cell
7
N
Y
VERSIONS
Negotiate a link protocol
8
N
Y
NETINFO
IP address info
129
N
N
CERTS
Certificates


In the table above, C=Y indicates that a command must have a non-zero CircID, and C=N indicates that a command must have a zero CircID. Additionally, L=Y indicates that a command must specify the length of its body, and L=N indicates that a command has a fixed-length body. In this lab, NO other command values are allowed. Your implementation should not send any undefined command values.

Interpreting the fields: Body. The interpretation of a cell's Body depends on the cell's command. More information on each command is provided throughout the handout below.

(Important) Data sent over a socket should always have the format of **big endian**.
Task 0: Basic settings
Linux environment. This assignment is graded inside a container of Ubuntu 22.04. Thus, to avoid any unnecessary environment mismatches, we highly recommend you to conduct all the tasks in Ubuntu 22.04 when doing the lab locally.

Files. You should see the following files inside directory:
mini_auth.py: Fully functional authority server. You should not modify anything inside.
mini_cell.py: The file to create cells. You can use this file to implement your own definitions of cells (or you may implement them elsewhere).
mini_client.py: Your client’s code should be written here.
mini_crypt.py: All the wrapper functions to use cryptographic functions are here. You also may find some helpful examples inside.
mini_relay.py: Your relay’s code should be written here.
mini_web_server.py: Fully functional web server. You should not modify anything inside.
run.py: The file that spawns the authority, web server, client, and relays as threads. You can use this file to test your codes.
You may define your own functions. And you may use any libraries that the autograder in the gradescope can download and run. The autograder will try to download python libraries listed in the requirements.txt. So, if you want to use other libraries, define them in requirements.txt. You may find pip freeze > requirements.txt helpful.

Basic setup. You can find Makefile inside the directory. With the command make init, you can create the data directory along with the PEM files in their appropriate locations. PEM files are files to store RSA public and private keys, and they are used to generate signatures and do encryption in this lab, thus do not move or temper with the file.

We assume that all entities have access to the authority’s public key; this key is stored as Authority.pub in each entity’s key directory.

After executing make init, You can try to run the protocol with the command python3 run.py. After the run, you should be able to find each entities’ logs inside the data directory. For example, relay 1’s log will be stored as data/OnionRouter1/OnionRouter1.log.

We assume that all relays know other relays’ public key and IP address information before a client comes in. You can see this in run.py. Note that the relays first register to the authority, and after a while they fetch the descriptors from the authority. All processes regarding registering to the authority and fetching descriptors from the authority are provided, thus you do not have to implement this process.
Task 1: Opening a channel and a circuit to the first relay (30 points)
Task 1-1: Opening a channel to the first relay
The very first thing that a client does is to open a channel to the first-hop relay. A channel is a connection between two relays, or between a client and a relay. Clients and relays may both open new channels; only a relay may be the recipient of a channel.

Opening a channel is multi-step process:
The initiator opens a new socket then sends a VERSIONS cell to the responder.
Upon receiving a VERSIONS cell, the responder replies with VERSIONS, CERTS, and NETINFO cells sequentially to prove the ownership of the identity key. The cells should be sent in the exact order.
After the initiator verifies the cells, the initiator replies to the NETINFO cell to finish the handshake and open a channel.



In run.py, you can see the circuit is given to the client as a list of relays’ nicknames. You must construct the circuit with the order, for example, the relay indexed zero is the first hop.
VERSIONS cell
A VERSIONS cell is used to negotiate which version will the initiator and the responder use. The body in VERSIONS cell is a series of big-endian two-byte integers. This lab currently supports only protocol version 3.

Initiator’s behavior. An initiator sends a VERSION cell to open a channel. The initiator sends 3 in two bytes integer formatted in big endian.

Responder’s behavior. When a relay receives a VERSIONS cell, it responds with VERSIONS, CERTS, and NETINFO cells sequentially.

A VERSIONS cell is a variable-length cell. Its body format is as follows:
Field
Size in bytes
Notes
Protocol version
2
Big endian two byte integer

CERTS cell
A CERTS cell proves that the identity key fetched from the authority belongs to the entity. To generate a proof, the responder (prover) creates a signature using the RSA private key on the data from the public key PEM file (in bytes).

Responder’s behavior. The channel responder sends a CERTS cell after it sends a VERSIONS cell. For the cell body, the responder should always pad the remaining 388(=1024-380-256) bytes with zeros.

Initiator’s behavior. The channel initiator never has to send a CERTS cell. When it receives a CERTS cell, it verifies the signature.
A CERTS cell is a fixed-length cell. Its body format is as follows:
Field
Size in bytes
Notes
PEM
380
The same one registered to the authority
Signature
256
In raw bytes

NETINFO cell
To finish the handshake, each party sends the other NETINFO cell. The address fields are strings indicating the IP address and the port, for example, ‘127.0.0.1:34134’. The cell sender should use the cell receiver’s address as the peer address field, and the cell receiver should consider the peer address field of the cell as the cell receiver’s address.

Initiator’s behavior. When the initiator receives a NETINFO cell, it should always confirm the IP address is correct. The Initiator then sends a NETINFO cell to finish the handshake and to indicate the received VERSIONS, CERTS, and NETINFO cells are well-formed.

Responder’s behavior. After sending the VERSIONS and CERTS cell, the responder sends the NETINFO cell to finish the handshake. When the responder receives a NETINFO cell, it should always confirm the IP address is correct.

A NETINFO cell is a variable-length cell. Its body format is as follows:
Field
Size in bytes
Notes
Peer’s address len
1
Big endian one byte integer
Peer’s address
Peer’s address len
<IP address>:<port>
My address len
1
Big endian one byte integer
My address
My address len
<IP address>:<port>

Task 1-2: Opening a circuit to the first relay
Clients set up circuits incrementally, one hop at a time. After the channel to the first relay is open, the client can now send a CREATE cell to the relay to open the circuit’s first hop. The purpose of the CREATE/CREATED cells are to derive symmetric shared keys. Our mini onion routing protocol uses the Diffie-Hellman key exchange scheme to derive a symmetric key.

To open a circuit, the entities use CREATE/CREATED to do a handshake:
The initiator first generates a public-private Diffie-Hellman key pair, then the initiator sends the DH public key inside a CREATE cell over the opened channel.
Receiving the CREATE cell, the responder also generates a public-private Diffie-Hellman key pair and sends the DH public key inside a CREATED cell. Since the responder knows its DH private key and the initiator’s DH public key, the responder can derive the shared secret key between them.
After the initiator receives the CREATED cell, it also knows its DH private key and responder’s DH public key, the initiator can also derive the shared secret between them.



CREATE cell
A CREATE cell is sent by the initiator to establish shared secrets. The client should encrypt its Diffie-Hellman public key using the relay’s RSA public key, so only the relay with the corresponding private key can decrypt the message and know the public key. The Diffie-Hellman public key should be encoded in the base16 format and have the length of 128.

Circuit ID. The circuit ID is used to identify which cell belongs to which circuit. The initiator of the channel should decide and announce a unique circuit ID between the initiator and the responder when it is sending a CREATE cell after the channel is established. In this lab, we will use simple rules to avoid collisions. The client should always use the circuit ID defined in the run.py when client is the channel initiator; and relays should generate a random number between cric_id_base and circ_id_base+999 (cric_id_base is also defined in the run.py) when they become the initiator of the channel.

Client’s behavior. The client generates a DH public-private key pair. The private key should be stored securely, while the public key is sent to the relay. The DH public key should be encoded in base16 and encrypted with the receiving relay’s public key.

Relay’s behavior. When the relay receives a CREATE cell, it decrypts the cell and extracts the DH public key encoded in the base16 format. Since the relay can generate a Diffie-Hellman public-private key pair immediately, the relay can derive the shared secret key after receiving the CREATE cell. After successfully deriving the shared key, it stores the derived shared key and sends a CREATED cell back to the initiator.

(Hint: Use the built-in Python functions format(variable,‘x’) to encode in base16, zfill(length) to pad the result, and int(variable, 16) to decode from base16.)
A CREATE cell is a variable-length cell. Its body format is as follows:
Field
Size in bytes
Notes
Encrypted DH public key
256
Encrypted with the receiver’s public key; the public key should be encoded with base16 and have the length of 128

CREATED cell
A CREATED cell is sent by the responding relay to finish the handshake and establish shared secrets. The DH public key should also be encoded in base16 and have the length of 128. Unlike the CREATE cell, the sender’s Diffie-Hellman public key is not encrypted with the receiver’s public key; but a signature on the DH public key is attached to the cell. The signature is generated using the sender’s RSA private key on the DH public key.

Relay’s behavior. The relay generates a DH public-private key pair. Identical to the client, it should encode the public key into the base16 format with the length of 128. Then it generates a signature using its own RSA private key.

Client’s behavior. The client first verifies the signature and checks whether the public key is modified or it is actually from the expected entity. After the verification, the client derives the shared secret key.

A CREATED cell is a variable-length cell. Its body format is as follows:
Field
Size in bytes
Notes
DH public key
128
Base16 encoding
Signature on the DH public key
256



Task 2: Extending the circuit (35 points)
After the client establishes a circuit with the first-hop relay, it begins extending the circuit. To do so, the client sends a RELAY cell to the last relay (relay M) in the current circuit (with a length of M). Upon receiving this RELAY cell, relay M processes it according to the relay command.

Extending the circuit involves multiple steps:
The client creates a RELAY cell with the EXTEND command and sends it to relay M, the last relay in the current circuit.
Upon receiving the RELAY-EXTEND cell, relay M checks two things:
The identity of the next relay (relay M+1) that the client wants to add to the circuit.
The contents of the cell body, which will later be used to construct a CREATE cell. Relay M then opens a channel with relay M+1.
Once the channel is established, relay M sends a CREATE cell to relay M+1, using the payload from the RELAY-EXTEND cell to fill the body of the CREATE cell.
After receiving a CREATED cell from relay M+1, relay M packages the CREATED cell’s body into a RELAY cell with the EXTENDED command and sends it back to the client.

Note that as the circuit grows, the last relay (relay M) changes. The client should continue extending the circuit until M equals to N. In this lab, N is set to 3.

 
RELAY cell
A RELAY cell is a cell used to send an end-to-end data along the circuit. Within a circuit, the client and the last relay in the circuit use the contents of RELAY cells to tunnel end-to-end connections across circuits. End-to-end commands can be initiated by either edge.

Upon receiving a RELAY cell, a relay first decrypts the cell — peeling off one layer of the onion — using the shared secret key derived earlier (recall Task 1-2). It then checks whether the cell is intended for itself. If the RELAY cell is not fully decrypted, the relay cannot interpret its contents and simply forwards it to the next relay.

The client should always encrypt the RELAY cell M times with different shared keys corresponding to each of the relays in the circuit. When the last relay, relay M, is sending a RELAY cell back to the client, it only encrypts using the shared secret key once. When the RELAY cell is transmitted back to the client, the RELAY cell gains the onion layers as it is transmitted along the circuit, and the client should decrypt it M times to see the content of the RELAY cell.

The body of an unencrypted RELAY cell looks like this (it is a fixed-length cell):
Field
Size in bytes
Notes
RELAY command
1
Big endian one byte integer
Recognized
2
Indicates the cell is still encrypted or not
Digest
4
Indicates the cell is still encrypted or not
Data len
2
Big endian two byte integer
Data
Data len
Format varies depending on the relay commands
Padding
1024 - 9 - data len
Padded to fit the fixed size (1024)


When a relay fully decrypts and recognizes the RELAY cell, it behaves according to the relay command. In this lab, there are six types of RELAY commands, as described below:
Command
Identifier
Description
1
BEGIN
Open a stream
2
DATA
Transmit data
3
END
Close a stream
4
CONNECTED
Stream has successfully opened
6
EXTEND
Extend a circuit
7
EXTENDED
Finish extending a circuit


More details about how relays handle each type of RELAY command are provided below.

Recognized field. The recognized field in a RELAY cell serves as a simple indicator of whether the cell is still encrypted. This field is an optimization that helps avoid computing expensive digests for every cell. When sending cells, the unencrypted recognized field MUST be set to zero. Upon receiving and decrypting a cell, the recognized field will be zero only if the cell is intended for the current relay. For cells that should be forwarded, the recognized field will normally be non-zero, although it may occasionally be zero by chance (with probability 2-16).

Digest field. The digest field is used to verify whether a cell has been fully decrypted; that is, all of its onion layers have been removed. Since the recognized field alone is not sufficient to confirm this (as noted above), the digest provides an additional layer of validation.

When generating a RELAY cell, one follows these steps to correctly compute the digest:
# encode the cell in bytes (recognized field and digest field set to zero)
tmp = relay_cmd + [0, 0] + [0, 0, 0, 0] + data_length + data + padding
# calculate the digest
digest = crc32(tmp)
# we now have the cell body
cell_body = relay_cmd + [0, 0] + digest + data_length + data + padding
# now we can encrypt the cell by adding onion layers …



When decrypting a RELAY cell, one follows these steps to correctly compute the digest:
# decrypt the cell body
decrypted = decrypt(cell_body)
# replace the digest field in decrypted by zeros
tmp = decrypted[0..2] + [0, 0, 0, 0] + decrypted[7..]
# calculate the digest
digest = crc32(tmp)
if digest == decrypted[3..6]
    # the cell has been fully decrypted


Padding field. The body of a RELAY cell must have the length of 1024. When the body is shorter than 1024 bytes, the remaining bytes have to be padded with zeros. In this lab, we will not have a cell body longer than 1024 bytes, thus you do not have to worry about fragmenting the data.
RELAY-EXTEND  
A RELAY cell with the EXTEND relay command is sent by a client to extend the circuit.

Client’s behavior. When a client tries to send a RELAY-EXTEND cell to relay M, which is the last relay of the current circuit, the client encrypts the cell M times. For example, if the circuit (length of 2) is established with OR1 and OR2, the client encrypts the cell twice: using the key shared with OR1, then using the key shared with OR2. The client should send a RELAY-EXTEND cell repeatedly until it has established a shared secret key with all N relays in the circuit (N is 3 in this lab).

Relay’s behavior. When a relay receives a RELAY cell with EXTEND command, it opens a channel to relay M+1 specified in the RELAY-EXTEND cell. Similar to how a client opens a channel, the initiating relay, relay M, sends a VERSIONS cell to relay M+1. Relay M then waits to receive VERSIONS, CERTS, and NETINFO cells, then it sends a NETINFO cell to finish the handshake and open the channel. After opening the channel, relay M sends a CREATE cell. Unlike the client who generated a Diffie-Hellman key pair, relay M constructs the CREATE cell using the encrypted DH public key field from the received RELAY-EXTEND cell.

A RELAY-EXTEND cell’s body format is as follows:
Body field
Size in bytes
Notes
OR name len
1
Big endian one byte integer
OR name
OR name len
Relay nickname
Encrypted DH public key
256
Encrypted with the receiver’s public key; the public key should be encoded in base16 format and have the length of 128

RELAY-EXTENDED
A RELAY cell with the EXTENDED relay command is sent by relay M, who is the last relay in the circuit and just received the RELAY-EXTENDED cell, back to the client. Note that the circuit is only considered extended once the client receives this RELAY-EXTENDED cell. Until then, relay M remains the last relay in the circuit. Once the client receives the RELAY-EXTENDED cell, relay M is no longer the final node in the circuit.

Relay’s behavior. When relay M opens a channel and receives a CREATED cell from the newly extended relay (relay M+1), relay M creates a RELAY-EXTENDED cell based on the received CREATED cell and sends it back to the client. Relay M should not modify any of the fields in the received CREATED cell but just pack them into a RELAY-EXTENDED cell.

Client’s behavior. When the client receives the RELAY-EXTENDED cell from the relay, it derives the shared secret key as it did when it received the CREATED cell. The client should repeat this process until it has established a shared secret key with each of N relays in the circuit (N is 3 in this lab).

A RELAY-EXTENDED cell’s body format is as follows:
Body field
Size in bytes
Notes
Diffie-Hellman public key
128
Should be encoded in base16 format and have the length of 128
Signature on the DH public key
256



Task 3: Connecting to a web server via the circuit (25 points)
After the client has established shared secret keys with all N relays in the circuit, the circuit is fully open and ready for use. Connecting to a web server through the circuit involves multiple steps:
The client sends a RELAY cell with the BEGIN relay command to the last relay in the circuit, relay N. This cell is encrypted N times (once per relay).
Each relay in the middle decrypts one layer of encryption. Since the cell is not intended for them, they cannot read its contents and simply forward it to the next relay.
When relay N receives and recognizes the RELAY-BEGIN cell, it opens a socket connection to the requested web server (without yet sending data).
Once the web server accepts the socket connection, relay N sends a RELAY cell with the CONNECTED relay command back to the client. This cell is encrypted once, using the shared secret key between relay N and the client.
Each intermediate relay encrypts the cell once using its shared key and forwards it.
After receiving the RELAY-CONNECTED cell, the client sends a RELAY-DATA cell to relay N. The data inside the cell contains the HTTP request for the web server. Note that you don’t need to consider TLS in this lab.
Each intermediate relay handles this RELAY-DATA cell just as in earlier steps: decrypt one layer, then forward.
Relay N extracts the HTTP data from the cell and sends it to the web server.
After receiving the server’s response, relay N creates a RELAY-DATA cell containing the response, encrypts it once, and sends it back toward the client.
Each intermediate relay decrypts one layer and forwards the cell, just like in previous steps.
The client receives the RELAY-DATA cell, decrypts it, and extracts the web server’s response.


RELAY-BEGIN
A RELAY cell with the BEGIN relay command is used when the client wants to connect to the web server.

Client behavior. The client specifies the IP address and the port of the web server in the RELAY-BEGIN cell. Similar to the format in NETINFO, the address format should be <IP address>:<port>; e.g., 127.0.0.1: 8080. Since it is a RELAY cell, the client encrypts the cell N times.

Relay’s behavior. When relay N receives the RELAY-BEGIN cell, it opens a socket to the web server.

RELAY-BEGIN cell’s body format is:
Body field
Size in bytes
Notes
Target address len
1
Big endian one byte integer
Target address
Target address len
<IP address>:<port>

RELAY-CONNECTED
A RELAY cell with the CONNECTED relay command is used to indicate that relay N has successfully opened the socket with the web server.

Relay’s behavior. When relay N has opened the socket with the web server, it creates a RELAY-CONNECTED cell and sends it back to the client. The body of the cell specifies the IP address of the web server. Identical to other RELAY cells, relay N encrypts the cell with the shared secret key once.

Client’s behavior. When the client receives the RELAY-CONNECTED cell, it knows that it is ready to send a RELAY cell with the DATA relay command.

A RELAY-CONNECTED cell’s body format is as follows:
Body field
Size in bytes
Notes
Target address len
1
Big endian one byte integer
Target address
Target address len
<IP address>:<port>

RELAY-DATA
A RELAY cell with the DATA relay command is used to transmit the data. In this lab, that data consists of HTTP requests and responses.

Client’s behavior. Once the client learns that the connection to the web server has been established, it sends an HTTP request packaged inside a RELAY-DATA cell. When the client receives a RELAY-DATA cell containing the server’s response, it can terminate the connection and circuit for the lab. (Note that you can find an example HTTP request in the provided code.)

Relay’s behavior. When relay N receives a RELAY-DATA cell, it reads data len bytes of data and forwards it to the web server. Upon receiving a response from the web server, relay N packages the response into a new RELAY-DATA cell and sends it back to the client.

A RELAY-DATA cell’s body format is as follows:
Body field
Size in bytes
Notes
Data
Data len
Data len is the big endian two byte integer from the RELAY cell body

Task 4: Closing the circuit (10 points)
Once the client has received the web server’s response, it can gracefully terminate the connection. This process involves several steps:
The client sends a RELAY cell with the END relay command.
Each relay in the middle decrypts one layer and forwards the RELAY-END cell to the next relay.
When relay N (the last relay) receives the RELAY-END cell, it closes its socket connection to the web server. No response is sent back to the client.
The client then sends a DESTROY cell to relay 1 and closes its own socket connected to relay 1.
When any relay M receives a DESTROY cell:
It closes the socket connected to the sender of the DESTROY cell.
If there is a subsequent relay (M+1) in the circuit, it forwards a DESTROY cell to relay M+1 and closes its own socket.


RELAY-END
A RELAY cell with the END relay command is used by the client to instruct the last relay in the circuit (relay N) to close its socket connection to the web server.

Client’s behavior. The client sends a RELAY cell with the END relay command, where the cell body consists only of padding. The cell is encrypted N times, just like other RELAY cells sent through the circuit.

Relay’s behavior. When relay N receives and recognizes a RELAY-END cell, it closes the socket to the web server. No response is sent back to the client.

A RELAY-END cell’s body format is as follows:
Body field
Size in bytes
Notes
-
0
Only paddings

DESTROY cell
A DESTROY cell is used to tear down a circuit. Note that this is not a RELAY cell.

Client’s behavior. The client initiates circuit teardown by sending a DESTROY cell to the first relay in the circuit. The body of this cell consists only of padding. After sending the DESTROY cell, the client can close its socket connection.

Relay’s behavior. When a relay receives a DESTROY cell, it closes the socket connected to the sender of the cell. If there is a next-hop relay in the circuit, it forwards a DESTROY cell to that relay and then closes the corresponding socket.
A DESTROY cell’s body format is as follows:
Field
Size in bytes
Notes
-
0
No cell body but only padding

Grading
Once your codes are uploaded to the gradescope, your mini_client.py and mini_relay.py will be graded separately against the TA’s relay and the TA’s client (which are the reference implementations of the client and relay and they are hidden from the students), respectively. That is, the autograder tests the two python submissions separately as follows:
When grading your mini_client.py, the autograder tries to construct a circuit using our TA_relay.py and your mini_relay.py.
When grading your mini_relay.py, our TA_client.py in the autograder tries to construct the circuit using our TA_relay.py and your mini_relay.py.
If you don’t strictly follow the protocol, the grading will fail.
Gradescope Submission
Your submission must be in ZIP format.
Name your ZIP file as {SID}.zip, where {SID} is your student ID. The make zip command may be helpful for creating this file.
The {SID}.zip should include everything needed to run your mini_client.py and mini_relay.py. You may create and use additional files you want. But you are NOT allowed to rename any of the provided files (e.g., mini_client.py, mini_relay.py), as this may cause issues during autograding. If grading fails due to this, no points will be given.
If you use any external Python libraries, list them clearly in a requirements.txt.
After submitting, you should immediately see your score. This score will be final for the lab.
Acknowledgement
I would like to express my sincere gratitude to Eunchan (Paul) Park, who made this lab possible through his considerable time and effort. If you find this lab engaging or insightful, please give him a well-deserved round of applause!
Side Note
After completing this lab, some of you may find anonymity networks to be an especially fascinating topic. Although the core principle is relatively simple (i.e., routing traffic through multiple hops to obscure its origin), the impact is huge. For instance, around 2.5 million people actively use Tor every day [1]. Anonymous communication is important in both (relatively) open and repressive regimes, as it protects individual privacy to the highest degree, even against powerful actors such as governments or large corporations. This strong privacy protection is fundamental to democracy, enabling one of its most essential values: namely, the free and open flow of information [2, 3].

However, every light has its shadow. The very same privacy protections that shield users from surveillance also make it difficult to track and prosecute criminals, contributing to the risk of dark online environments. When combined with decentralized finance (DeFi), anonymous networks have facilitated a wide range of illegal activities [4–7]. These include the trade of illicit goods and services such as narcotics, contract killings, and child sexual abuse materials (CSAM). The challenge of designing an anonymity network that ensures both privacy and public safety remains largely unresolved — usually, pursuing one compromises the other.

Furthermore, anonymity networks are not immune to attack. Since their inception, numerous attacks that exploit various vulnerabilities of these systems have been proposed [8–10], and researchers continue to discover new vulnerabilities even today [11–13].

In summary, anonymity networks are indeed both interesting and important areas of research. Their fundamental dilemma (i.e., striking a balance between public safety and strong anonymity) remains unsolved, and many of their security aspects still require deeper exploration. If you are interested in pursuing cutting-edge research in this area, whether through a lab internship, URP, or individual study (개별연구), please reach out to our professor, Prof. Min Suk Kang, to discuss potential opportunities. I hope to work with you soon! – Jinseo “Vik” Lee

[1] The Tor Project. “Users – Tor Metrics.” Accessed November 2025. https://metrics.torproject.org/userstats-relay-country.html
[2] Glenn Greenwald. “NSA collecting phone records of millions of Verizon customers daily.” The Guardian. 2013. https://www.theguardian.com/world/2013/jun/06/nsa-phone-records-verizon-court-order
[3] SecureDrop. “Share and accept documents securely.” Accessed November 2025. https://securedrop.org/
[4] Alex Biryukov et al. “Content and Popularity Analysis of Tor Hidden Services.” In Proc. the 34th International Conference on Distributed Computing Systems Workshop (ICDCSW). 2014.
[5] Nicolas Christin. “Traveling the silk road: a measurement analysis of a large anonymous online marketplace.” In Proc. the 22nd international conference on World Wide Web (WWW). 2013.
[6] Gareth Owen and Nick Savage. “Empirical analysis of Tor Hidden Services.” In IET Inf. Secur. 10, no. 3,  pp. 113–118. 2016.
[7] U.S. Immigration and Custom Enforcement. “Dozens of ‘Dark Market’ websites seized as part of Silk Road 2.0 investigation.” 2014. https://www.ice.gov/news/releases/dozens-dark-market-websites-seized-part-silk-road-20-investigation
[8] Lasse Overlier and Paul Syverson. “Locating hidden servers.” In Proc. 27th IEEE Symposium on Security and Privacy (S&P). 2006.
[9] Aaron Johnson et al. “Users get routed: traffic correlation on tor by realistic adversaries.” In Proc. the 2013 ACM SIGSAC conference on Computer & communications security (CCS). 2013.
[10] Jean-François Raymond. “Traffic Analysis: Protocols, Attacks, Design Issues, and Open Problems.” In Proc. Workshop on Design Issues in Anonymity and Unobservability (PETS). 2000.
[11] Daniela Lopes et al. “Flow Correlation Attacks on Tor Onion Service Sessions with Sliding Subset Sum.” In Proc. the 31st Network and Distributed System Security Symposium (NDSS). 2024.
[12] Zhongtang Luo et al. “Attacking and Improving the Tor Directory Protocol.” In Proc. 45th IEEE Symposium on Security and Privacy (S&P). 2024.
[13] Jinseo Lee et al. “Onions Got Puzzled: On the Challenges of Mitigating Denial-of-Service Problems in Tor Onion Services.” In Proc. 34th USENIX Security Symposium (USENIX Security). 2025.
